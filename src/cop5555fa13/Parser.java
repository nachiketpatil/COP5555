/***************************************************************************
 ************************  Parser *****************************************
 **************************************************************************/

package cop5555fa13;

import java.util.ArrayList;
import java.util.List;

import cop5555fa13.TokenStream;
import cop5555fa13.TokenStream.Token;
import cop5555fa13.TokenStream.Kind;
import cop5555fa13.ast.AlternativeStmt;
import cop5555fa13.ast.AssignExprStmt;
import cop5555fa13.ast.AssignPixelStmt;
import cop5555fa13.ast.BinaryExpr;
import cop5555fa13.ast.BooleanLitExpr;
import cop5555fa13.ast.ConditionalExpr;
import cop5555fa13.ast.Dec;
import cop5555fa13.ast.Expr;
import cop5555fa13.ast.FileAssignStmt;
import cop5555fa13.ast.IdentExpr;
import cop5555fa13.ast.ImageAttributeExpr;
import cop5555fa13.ast.IntLitExpr;
import cop5555fa13.ast.IterationStmt;
import cop5555fa13.ast.PauseStmt;
import cop5555fa13.ast.Pixel;
import cop5555fa13.ast.PreDefExpr;
import cop5555fa13.ast.Program;
import cop5555fa13.ast.SampleExpr;
import cop5555fa13.ast.ScreenLocationAssignmentStmt;
import cop5555fa13.ast.SetVisibleAssignmentStmt;
import cop5555fa13.ast.ShapeAssignmentStmt;
import cop5555fa13.ast.SinglePixelAssignmentStmt;
import cop5555fa13.ast.SingleSampleAssignmentStmt;
import cop5555fa13.ast.Stmt;

/**
 * A Parser class that parses the token stream generated by the scanner. This
 * parser goes through all the tokens in sequence with Recursive descent
 * approach. We have adopted the LL(1) parser for Recursive descent. The grammar
 * or EBNF is given for this parser. If the input is correct according to given
 * grammar, it returns normally else throws a SyntaxException with the token
 * that is out of place. Revision 1: Generation of Abstract Syntaxt Tree with
 * the recursive descent \ approach. Each call to a grammar rule method returns
 * a node of AST.
 * 
 * @author Nachiket
 * 
 */
public class Parser {

	@SuppressWarnings("serial")
	public class SyntaxException extends Exception {
		Token t;

		public SyntaxException(Token t, String msg) {
			super(msg);
			this.t = t;
		}

		public String toString() {
			return super.toString() + "\n" + t.toString();
		}

		public Kind getKind() {
			return t.kind;
		}
	}

	/**
	 * Stream of tokens that holds the tokens scanned by the scanner.
	 */
	TokenStream stream;

	/**
	 * Index for the token stream to hold current token index.
	 */
	int index;

	Token progName; // keep the program name in case you don't generate an AST
	List<SyntaxException> errorList; // save the error for grading purposes

	/**
	 * creates a simple parser.
	 * 
	 * @param initialized_stream
	 *            a TokenStream that has already been initialized by the Scanner
	 */
	public Parser(TokenStream initialized_stream) {
		this.stream = initialized_stream;
		index = 0;
		errorList = new ArrayList<SyntaxException>();
	}

	public List<SyntaxException> getErrorList() {
		return errorList;
	}

	public String getProgName() {
		return (progName != null ? progName.getText() : "no program name");
	}

	/*
	 * This method parses the input from the given token stream. If the input is
	 * correct according to the phrase structure of the language, it returns
	 * normally. Otherwise it throws a SyntaxException containing the Token
	 * where the error was detected and an appropriate error message.
	 */
	public Program parse() throws SyntaxException {

		Program prog;
		if (stream.tokens.size() > 1) {
			progName = stream.getToken(0);
			prog = parseProgram();
			if (!isKind(stream.getToken(index), TokenStream.Kind.EOF)) {
				errorList.add(new SyntaxException(stream.getToken(index),
						"Invalid Token."));
			}
		} else {
			Token t = stream.new Token(TokenStream.Kind.EOF, 0, 1);
			errorList.add(new SyntaxException(t, "Empty Program."));
			return null;
		}

		return prog;
	}

	private Program parseProgram() throws SyntaxException {

		// Lists for Declarations and Statements
		List<Dec> decList = new ArrayList<Dec>();
		List<Stmt> stmtList = new ArrayList<Stmt>();

		// The program name
		progName = parseIdent();

		lbrace();

		while (true) {
			if (isKind(stream.getToken(index), TokenStream.Kind.image,
					TokenStream.Kind.pixel, TokenStream.Kind._int,
					TokenStream.Kind._boolean)) {
				try {
					Dec dec = parseDeclaration();
					if(dec != null) {
						decList.add(dec);
					}
				} catch (SyntaxException e) {
					errorList.add(e);
					while (!isKind(stream.getToken(index),
							TokenStream.Kind.SEMI, TokenStream.Kind._int,
							TokenStream.Kind._boolean, TokenStream.Kind.pixel,
							TokenStream.Kind.EOF)) {
						consume();
					}
					if (isKind(stream.getToken(index), TokenStream.Kind.SEMI)) {
						consume();
					}

				}
			} else if (isKind(stream.getToken(index), TokenStream.Kind.RBRACE)) {
				break;
			} else if (isKind(stream.getToken(index), TokenStream.Kind.EOF)) {
				errorList.add(new SyntaxException(stream.getToken(index),
						"Invalid token."));
				return null;
			} else if (isKind(stream.getToken(index), TokenStream.Kind.IDENT,
					TokenStream.Kind.pause, TokenStream.Kind._while,
					TokenStream.Kind._if, TokenStream.Kind.SEMI)) {
				try {

					Stmt stmt = parseStatement();
					if(stmt != null) {
						stmtList.add(stmt);
					}
				} catch (SyntaxException e) {
					errorList.add(e);
					while (!isKind(stream.getToken(index),
							TokenStream.Kind.SEMI, TokenStream.Kind._if,
							TokenStream.Kind._while, TokenStream.Kind.pause,
							TokenStream.Kind.EOF)
							&& !(isKind(stream.getToken(index),
									TokenStream.Kind.IDENT) && isKind(
									stream.getToken(index + 1),
									TokenStream.Kind.DOT))
							&& !(isKind(stream.getToken(index),
									TokenStream.Kind.IDENT) && isKind(
									stream.getToken(index + 1),
									TokenStream.Kind.ASSIGN))) {
						consume();
						if (isKind(stream.getToken(index), TokenStream.Kind.EOF)) {
							errorList.add(new SyntaxException(stream
									.getToken(index), "Invalid token."));
							return null;
						}
					}
					if (isKind(stream.getToken(index), TokenStream.Kind.SEMI)) {
						consume();
					}
				}
			}  else {
				errorList.add(new SyntaxException(stream.getToken(index),
						"Invalid token."));
				return null;
			}
		}
		rbrace();
		Program prog = new Program(progName, decList, stmtList);
		return prog;
	}

	private Dec parseDeclaration() throws SyntaxException {
		Kind type = parseType();
		Token ident = parseIdent();
		semicolon();
		Dec decl = new Dec(type, ident);
		return decl;
	}

	private Stmt parseStatement() throws SyntaxException {
		Stmt stmt = null;
		if (isKind(stream.getToken(index), TokenStream.Kind.IDENT)) {
			stmt = parseAssignStmt();
		} else if (isKind(stream.getToken(index), TokenStream.Kind.pause)) {
			stmt = parsePauseStmt();
		} else if (isKind(stream.getToken(index), TokenStream.Kind._while)) {
			stmt = parseWhileStmt();
		} else if (isKind(stream.getToken(index), TokenStream.Kind._if)) {
			stmt = parseIfStmt();
		} else if (isKind(stream.getToken(index), TokenStream.Kind.SEMI)) {
			semicolon();
		} else {
			errorList.add(new SyntaxException(stream.getToken(index),
					"Invalid token."));
			return null;
		}
		return stmt;
	}

	private Stmt parseWhileStmt() throws SyntaxException {
		Stmt stmt = null;
		List<Stmt> whlList = new ArrayList<Stmt>();
		keywordWhile();
		lparen();
		Expr expr = parseExpression();
		rparen();
		lbrace();
		while (true) {
			if (isKind(stream.getToken(index), TokenStream.Kind.RBRACE)) {
				break;
			} else if (isKind(stream.getToken(index), TokenStream.Kind.IDENT,
					TokenStream.Kind.SEMI, TokenStream.Kind.pause,
					TokenStream.Kind._while, TokenStream.Kind._if)) {
				try {
					Stmt whStmt = parseStatement();
					if(whStmt != null) {
						whlList.add(whStmt);
					}
				} catch (SyntaxException e) {
					errorList.add(e);
					while (!isKind(stream.getToken(index),
							TokenStream.Kind.SEMI, TokenStream.Kind._if,
							TokenStream.Kind._while, TokenStream.Kind.pause,
							TokenStream.Kind.EOF)
							&& !(isKind(stream.getToken(index),
									TokenStream.Kind.IDENT) && isKind(
									stream.getToken(index + 1),
									TokenStream.Kind.DOT))
							&& !(isKind(stream.getToken(index),
									TokenStream.Kind.IDENT) && isKind(
									stream.getToken(index + 1),
									TokenStream.Kind.ASSIGN))) {
						consume();
						if (isKind(stream.getToken(index), TokenStream.Kind.EOF)) {
							errorList.add(new SyntaxException(stream
									.getToken(index), "Invalid token."));
							return null;
						}
					}
					if (isKind(stream.getToken(index), TokenStream.Kind.SEMI)) {
						consume();
					}
				}
			}
		}
		rbrace();

		stmt = new IterationStmt(expr, whlList);
		return stmt;
	}

	private Stmt parseIfStmt() throws SyntaxException {

		Expr expr = null;
		List<Stmt> ifStmtList = new ArrayList<Stmt>();
		List<Stmt> elseStmtList = new ArrayList<Stmt>();

		keywordIf();
		lparen();
		expr = parseExpression();
		rparen();
		lbrace();

		while (true) {
			if (isKind(stream.getToken(index), TokenStream.Kind.RBRACE)) {
				break;
			} else if (isKind(stream.getToken(index), TokenStream.Kind.EOF)) {
				errorList.add(new SyntaxException(stream.getToken(index),
						"Invalid token."));
				return null;
			} else if (isKind(stream.getToken(index), TokenStream.Kind.IDENT,
					TokenStream.Kind.SEMI, TokenStream.Kind.pause,
					TokenStream.Kind._while, TokenStream.Kind._if)) {
				try {
					Stmt condStmt =  parseStatement();
					if(condStmt != null) {
						ifStmtList.add(condStmt);
					}
				} catch (SyntaxException e) {
					errorList.add(e);
					while (!isKind(stream.getToken(index),
							TokenStream.Kind.SEMI, TokenStream.Kind._if,
							TokenStream.Kind._while, TokenStream.Kind.pause,
							TokenStream.Kind.RBRACE)
							&& !(isKind(stream.getToken(index),
									TokenStream.Kind.IDENT) && isKind(
									stream.getToken(index + 1),
									TokenStream.Kind.DOT))
							&& !(isKind(stream.getToken(index),
									TokenStream.Kind.IDENT) && isKind(
									stream.getToken(index + 1),
									TokenStream.Kind.ASSIGN))) {
						consume();
					}
					if (isKind(stream.getToken(index), TokenStream.Kind.SEMI,
							TokenStream.Kind.RBRACE)) {
						consume();
					}
				}
			}
		}
		rbrace();

		if (isKind(stream.getToken(index), TokenStream.Kind._else)) {
			keywordElse();
			if (isKind(stream.getToken(index), TokenStream.Kind._if)) {
				Stmt stmt = parseIfStmt();
				if(stmt != null) {
					elseStmtList.add(stmt);
				}
			} else {
				lbrace();
				while (true) {
					if (isKind(stream.getToken(index), TokenStream.Kind.RBRACE)) {
						break;
					} else if (isKind(stream.getToken(index),
							TokenStream.Kind.EOF)) {
						errorList.add(new SyntaxException(stream
								.getToken(index), "Invalid token."));
						return null;
					} else if (isKind(stream.getToken(index),
							TokenStream.Kind.IDENT, TokenStream.Kind.SEMI,
							TokenStream.Kind.pause, TokenStream.Kind._while,
							TokenStream.Kind._if)) {
						try {
							Stmt condStmt =  parseStatement();
							if(condStmt != null) {
								elseStmtList.add(condStmt);
							}
						} catch (SyntaxException e) {
							errorList.add(e);
							while (!isKind(stream.getToken(index),
									TokenStream.Kind.SEMI,
									TokenStream.Kind._if,
									TokenStream.Kind._while,
									TokenStream.Kind.pause,
									TokenStream.Kind.RBRACE)
									&& !(isKind(stream.getToken(index),
											TokenStream.Kind.IDENT) && isKind(
											stream.getToken(index + 1),
											TokenStream.Kind.DOT))
									&& !(isKind(stream.getToken(index),
											TokenStream.Kind.IDENT) && isKind(
											stream.getToken(index + 1),
											TokenStream.Kind.ASSIGN))) {
								consume();
							}
							if (isKind(stream.getToken(index),
									TokenStream.Kind.SEMI,
									TokenStream.Kind.RBRACE)) {
								consume();
							}
						}
					}
				}
				rbrace();
			}
		}
		Stmt ifStmt = new AlternativeStmt(expr, ifStmtList, elseStmtList);
		return ifStmt;
	}

	private Stmt parseAssignStmt() throws SyntaxException {
		Stmt stmt = null;
		Token lhsToken = parseIdent();

		if (isKind(stream.getToken(index), TokenStream.Kind.ASSIGN)) {
			assign();
			if (isKind(stream.getToken(index), TokenStream.Kind.LBRACE)) {
				Pixel pix = parsePixeldata();
				stmt = new AssignPixelStmt(lhsToken, pix);
			} else if (isKind(stream.getToken(index),
					TokenStream.Kind.STRING_LIT)) {
				Token fileName = stringLit();
				stmt = new FileAssignStmt(lhsToken, fileName);
			} else {
				Expr expr = parseExpression();
				stmt = new AssignExprStmt(lhsToken, expr);
			}
		} else if (isKind(stream.getToken(index), TokenStream.Kind.DOT)) {
			dot();
			if (isKind(stream.getToken(index), TokenStream.Kind.pixels)) {
				pixels();
				lsquare();
				Expr xExpr = parseExpression();
				comma();
				Expr yExpr = parseExpression();
				rsquare();
				if (isKind(stream.getToken(index), TokenStream.Kind.red,
						TokenStream.Kind.green, TokenStream.Kind.blue)) {
					Token color = colors();
					assign();
					Expr rhsExpr = parseExpression();
					stmt = new SingleSampleAssignmentStmt(lhsToken, xExpr,
							yExpr, color, rhsExpr);
				} else {
					assign();
					Pixel pix = parsePixeldata();
					stmt = new SinglePixelAssignmentStmt(lhsToken, xExpr,
							yExpr, pix);
				}
			} else if (isKind(stream.getToken(index), TokenStream.Kind.shape)) {
				shape();
				assign();
				lsquare();
				Expr width = parseExpression();
				comma();
				Expr height = parseExpression();
				rsquare();
				stmt = new ShapeAssignmentStmt(lhsToken, width, height);

			} else if (isKind(stream.getToken(index), TokenStream.Kind.location)) {
				location();
				assign();
				lsquare();
				Expr xScreenExpr = parseExpression();
				comma();
				Expr yScreenExpr = parseExpression();
				rsquare();
				stmt = new ScreenLocationAssignmentStmt(lhsToken, xScreenExpr,
						yScreenExpr);
			} else if (isKind(stream.getToken(index), TokenStream.Kind.visible)) {
				visible();
				assign();
				Expr expr = parseExpression();
				stmt = new SetVisibleAssignmentStmt(lhsToken, expr);
			}
		} else {
			errorList.add(new SyntaxException(stream.getToken(index),
					"Invalid token."));
			return null;
		}
		semicolon();
		return stmt;
	}

	private Stmt parsePauseStmt() throws SyntaxException {
		keywordPause();
		Expr expr = parseExpression();
		semicolon();
		Stmt stmt = new PauseStmt(expr);
		return stmt;
	}

	private Expr parseExpression() throws SyntaxException {
		Expr expr = null;
		if (isKind(stream.getToken(index), TokenStream.Kind.NOT)) {
			not();
		}
		Expr orExpr = parseORExpression();
		if (isKind(stream.getToken(index), TokenStream.Kind.QUESTION)) {
			question();
			Expr trueValue = parseExpression();
			colon();
			Expr falseValue = parseExpression();
			expr = new ConditionalExpr(orExpr, trueValue, falseValue);
		} else {
			expr = orExpr;
		}
		return expr;
	}

	private Expr parseORExpression() throws SyntaxException {
		Expr expr = null;
		Expr rExpr = null;
		Token op = null;

		Expr lExpr = parseANDExpression();

		if (isKind(stream.getToken(index), TokenStream.Kind.OR)) {
			op = parseSignOR();
			rExpr = parseORExpression();
			expr = new BinaryExpr(lExpr, op, rExpr);
		} else {
			expr = lExpr;
		}
		return expr;
	}

	private Expr parseANDExpression() throws SyntaxException {
		Expr expr = null;
		Expr rExpr = null;
		Token op = null;

		Expr lExpr = parseEqualityExpr();

		if (isKind(stream.getToken(index), TokenStream.Kind.AND)) {
			op = parseSignAND();
			rExpr = parseANDExpression();
			expr = new BinaryExpr(lExpr, op, rExpr);
		} else {
			expr = lExpr;
		}
		return expr;
	}

	private Expr parseEqualityExpr() throws SyntaxException {
		Expr expr = null;
		Expr rExpr = null;
		Token op = null;

		Expr lExpr = parseRelExpr();

		if (isKind(stream.getToken(index), TokenStream.Kind.EQ,
				TokenStream.Kind.NEQ)) {
			if (isKind(stream.getToken(index), TokenStream.Kind.EQ)) {
				op = parseEqual();
			} else if (isKind(stream.getToken(index), TokenStream.Kind.NEQ)) {
				op = parseNEqual();
			}
			rExpr = parseEqualityExpr();
			expr = new BinaryExpr(lExpr, op, rExpr);
		} else {
			expr = lExpr;
		}
		return expr;
	}

	private Expr parseRelExpr() throws SyntaxException {

		Expr expr = null;
		Expr rExpr = null;
		Token op = null;

		Expr lExpr = parseShiftExpr();

		if (isKind(stream.getToken(index), TokenStream.Kind.LT,
				TokenStream.Kind.GT, TokenStream.Kind.LEQ, TokenStream.Kind.GEQ)) {
			if (isKind(stream.getToken(index), TokenStream.Kind.LT)) {
				op = lthan();
			} else if (isKind(stream.getToken(index), TokenStream.Kind.GT)) {
				op = gthan();
			} else if (isKind(stream.getToken(index), TokenStream.Kind.LEQ)) {
				op = leq();
			} else if (isKind(stream.getToken(index), TokenStream.Kind.GEQ)) {
				op = geq();
			}
			rExpr = parseRelExpr();
			expr = new BinaryExpr(lExpr, op, rExpr);
		} else {
			expr = lExpr;
		}
		return expr;
	}

	private Expr parseShiftExpr() throws SyntaxException {

		Expr expr = null;
		Expr rExpr = null;
		Token op = null;

		Expr lExpr = parseAddExpr();

		if (isKind(stream.getToken(index), TokenStream.Kind.LSHIFT,
				TokenStream.Kind.RSHIFT)) {
			if (isKind(stream.getToken(index), TokenStream.Kind.LSHIFT)) {
				op = lshift();
			} else if (isKind(stream.getToken(index), TokenStream.Kind.RSHIFT)) {
				op = rshift();
			}
			rExpr = parseShiftExpr();
			expr = new BinaryExpr(lExpr, op, rExpr);
		} else {
			expr = lExpr;
		}
		return expr;
	}

	private Expr parseAddExpr() throws SyntaxException {

		Expr expr = null;
		Expr rExpr = null;
		Token op = null;

		Expr lExpr = parseMultExpr();

		if (isKind(stream.getToken(index), TokenStream.Kind.PLUS,
				TokenStream.Kind.MINUS)) {
			if (isKind(stream.getToken(index), TokenStream.Kind.PLUS)) {
				op = plus();
			} else if (isKind(stream.getToken(index), TokenStream.Kind.MINUS)) {
				op = minus();
			}
			rExpr = parseAddExpr();
			expr = new BinaryExpr(lExpr, op, rExpr);
		} else {
			expr = lExpr;
		}
		return expr;
	}

	private Expr parseMultExpr() throws SyntaxException {

		Expr expr = null;
		Expr rExpr = null;
		Token op = null;

		Expr lExpr = parsePrimaryExpr();

		if (isKind(stream.getToken(index), TokenStream.Kind.TIMES,
				TokenStream.Kind.DIV, TokenStream.Kind.MOD)) {
			if (isKind(stream.getToken(index), TokenStream.Kind.TIMES)) {
				op = times();
			} else if (isKind(stream.getToken(index), TokenStream.Kind.DIV)) {
				op = div();
			} else if (isKind(stream.getToken(index), TokenStream.Kind.MOD)) {
				op = mod();
			}
			rExpr = parseMultExpr();
			expr = new BinaryExpr(lExpr, op, rExpr);
		} else {
			expr = lExpr;
		}
		return expr;
	}

	private Expr parsePrimaryExpr() throws SyntaxException {

		Expr expr = null;

		if (isKind(stream.getToken(index), TokenStream.Kind.IDENT)) {

			Token t = parseIdent();

			if (isKind(stream.getToken(index), TokenStream.Kind.LSQUARE)) {
				Token color = null;
				lsquare();
				Expr xLoc = parseExpression();
				comma();
				Expr yLoc = parseExpression();
				rsquare();
				if (isKind(stream.getToken(index), TokenStream.Kind.red,
						TokenStream.Kind.green, TokenStream.Kind.blue)) {
					color = colors();
				} else {
					errorList.add(new SyntaxException(stream.getToken(index),
							"Invalid token."));
					return null;
				}
				expr = new SampleExpr(t, xLoc, yLoc, color);

			} else if (isKind(stream.getToken(index), TokenStream.Kind.DOT)) {
				dot();
				Token selector = null;
				if (isKind(stream.getToken(index), TokenStream.Kind.height)) {
					selector = height();
				} else if (isKind(stream.getToken(index),
						TokenStream.Kind.width)) {
					selector = width();
				} else if (isKind(stream.getToken(index),
						TokenStream.Kind.x_loc)) {
					selector = xloc();
				} else if (isKind(stream.getToken(index),
						TokenStream.Kind.y_loc)) {
					selector = yloc();
				} else {
					errorList.add(new SyntaxException(stream.getToken(index),
							"Invalid token."));
					return null;
				}

				expr = new ImageAttributeExpr(t, selector);
			} else {
				expr = new IdentExpr(t);
			}

		} else if (isKind(stream.getToken(index), TokenStream.Kind.INT_LIT)) {
			Token t = intLit();
			expr = new IntLitExpr(t);
		} else if (isKind(stream.getToken(index), TokenStream.Kind.BOOLEAN_LIT)) {
			Token t = boolLit();
			expr = new BooleanLitExpr(t);
		} else if (isKind(stream.getToken(index), TokenStream.Kind.x)) {
			Token t = keywordX();
			expr = new PreDefExpr(t);
		} else if (isKind(stream.getToken(index), TokenStream.Kind.y)) {
			Token t = keywordY();
			expr = new PreDefExpr(t);
		} else if (isKind(stream.getToken(index), TokenStream.Kind.Z)) {
			Token t = keywordZ();
			expr = new PreDefExpr(t);
		} else if (isKind(stream.getToken(index), TokenStream.Kind.SCREEN_SIZE)) {
			Token t = screenSize();
			expr = new PreDefExpr(t);
		} else if (isKind(stream.getToken(index), TokenStream.Kind.LPAREN)) {
			lparen();
			expr = parseExpression();
			rparen();
		} else {
			errorList.add(new SyntaxException(stream.getToken(index),
					"Invalid token."));
			return null;
		}
		return expr;
	}

	private Pixel parsePixeldata() throws SyntaxException {
		lbrace();
		lbrace();
		Expr redExpr = parseExpression();
		comma();
		Expr greenExpr = parseExpression();
		comma();
		Expr blueExpr = parseExpression();
		rbrace();
		rbrace();
		Pixel pix = new Pixel(redExpr, greenExpr, blueExpr);
		return pix;
	}

	/*
	 * Java hint -- Methods with a variable number of parameters may be useful.
	 * For example, this method takes a token and variable number of "kinds",
	 * and indicates whether the kind of the given token is among them. The Java
	 * compiler creates an array holding the given parameters.
	 */
	private boolean isKind(Token t, Kind... kinds) {
		Kind k = t.kind;
		for (int i = 0; i != kinds.length; ++i) {
			if (k == kinds[i])
				return true;
		}
		return false;
	}

	// /////////////////////////// Keywords //////////////////////////////////
	private void keywordWhile() throws SyntaxException {
		Token t = stream.getToken(index);
		if (isKind(t, TokenStream.Kind._while)) {
			consume();
		} else {
			throw new SyntaxException(t, "Invalid Token");
		}
	}

	private void keywordIf() throws SyntaxException {
		Token t = stream.getToken(index);
		if (isKind(t, TokenStream.Kind._if)) {
			consume();
		} else {
			throw new SyntaxException(t, "Invalid Token");
		}
	}

	private void keywordElse() throws SyntaxException {
		Token t = stream.getToken(index);
		if (isKind(t, TokenStream.Kind._else)) {
			consume();
		} else {
			throw new SyntaxException(t, "Invalid Token");
		}
	}

	private void keywordPause() throws SyntaxException {
		Token t = stream.getToken(index);
		if (isKind(t, TokenStream.Kind.pause)) {
			consume();
		} else {
			throw new SyntaxException(t, "Invalid Token - pause");
		}
	}

	private Token colors() throws SyntaxException {
		Token t = stream.getToken(index);
		if (isKind(t, TokenStream.Kind.red, TokenStream.Kind.green,
				TokenStream.Kind.blue)) {
			consume();
		} else {
			throw new SyntaxException(t, "Invalid Token");
		}
		return t;
	}

	private void shape() throws SyntaxException {
		Token t = stream.getToken(index);
		if (isKind(t, TokenStream.Kind.shape)) {
			consume();
		} else {
			throw new SyntaxException(t, "Invalid Token");
		}
	}

	private void location() throws SyntaxException {
		Token t = stream.getToken(index);
		if (isKind(t, TokenStream.Kind.location)) {
			consume();
		} else {
			throw new SyntaxException(t, "Invalid Token");
		}
	}

	private void visible() throws SyntaxException {
		Token t = stream.getToken(index);
		if (isKind(t, TokenStream.Kind.visible)) {
			consume();
		} else {
			throw new SyntaxException(t, "Invalid Token");
		}
	}

	private void pixels() throws SyntaxException {
		Token t = stream.getToken(index);
		if (isKind(t, TokenStream.Kind.pixels)) {
			consume();
		} else {
			throw new SyntaxException(t, "Invalid Token");
		}
	}

	private Token keywordX() throws SyntaxException {
		Token t = stream.getToken(index);
		if (isKind(t, TokenStream.Kind.x)) {
			consume();
		} else {
			throw new SyntaxException(t, "Invalid Token");
		}
		return t;
	}

	private Token keywordY() throws SyntaxException {
		Token t = stream.getToken(index);
		if (isKind(t, TokenStream.Kind.y)) {
			consume();
		} else {
			throw new SyntaxException(t, "Invalid Token");
		}
		return t;
	}

	private Token keywordZ() throws SyntaxException {
		Token t = stream.getToken(index);
		if (isKind(t, TokenStream.Kind.Z)) {
			consume();
		} else {
			throw new SyntaxException(t, "Invalid Token");
		}
		return t;
	}

	private Token screenSize() throws SyntaxException {
		Token t = stream.getToken(index);
		if (isKind(t, TokenStream.Kind.SCREEN_SIZE)) {
			consume();
		} else {
			throw new SyntaxException(t, "Invalid Token");
		}
		return t;
	}

	private Token height() throws SyntaxException {
		Token t = stream.getToken(index);
		if (isKind(t, TokenStream.Kind.height)) {
			consume();
		} else {
			throw new SyntaxException(t, "Invalid Token");
		}
		return t;
	}

	private Token width() throws SyntaxException {
		Token t = stream.getToken(index);
		if (isKind(t, TokenStream.Kind.width)) {
			consume();
		} else {
			throw new SyntaxException(t, "Invalid Token");
		}
		return t;
	}

	private Token xloc() throws SyntaxException {
		Token t = stream.getToken(index);
		if (isKind(t, TokenStream.Kind.x_loc)) {
			consume();
		} else {
			throw new SyntaxException(t, "Invalid Token");
		}
		return t;
	}

	private Token yloc() throws SyntaxException {
		Token t = stream.getToken(index);
		if (isKind(t, TokenStream.Kind.y_loc)) {
			consume();
		} else {
			throw new SyntaxException(t, "Invalid Token");
		}
		return t;
	}

	// ////////////////// Terminal Tokens////////////////////////////////
	private Kind parseType() throws SyntaxException {
		Token t = stream.getToken(index);
		if (isKind(t, TokenStream.Kind.image, TokenStream.Kind.pixel,
				TokenStream.Kind._int, TokenStream.Kind._boolean)) {
			consume();
		} else {
			throw new SyntaxException(t, "Invalid Token.");
		}
		return t.kind;
	}

	private Token parseIdent() throws SyntaxException {
		Token t = stream.getToken(index);
		if (isKind(t, TokenStream.Kind.IDENT)) {
			consume();
		} else {
			errorList.add(new SyntaxException(stream.getToken(index),
					"Invalid token."));
			consume();
			return null;
		}
		return t;
	}

	private void lparen() throws SyntaxException {
		Token t = stream.getToken(index);
		if (isKind(t, TokenStream.Kind.LPAREN)) {
			consume();
		} else {
			throw new SyntaxException(t, "Invalid Token.");
		}
	}

	private void rparen() throws SyntaxException {
		Token t = stream.getToken(index);
		if (isKind(t, TokenStream.Kind.RPAREN)) {
			consume();
		} else {
			throw new SyntaxException(t, "Invalid Token.");
		}
	}

	private void semicolon() throws SyntaxException {
		Token t = stream.getToken(index);
		if (isKind(t, TokenStream.Kind.SEMI)) {
			consume();
		} else {
			throw new SyntaxException(t, "Invalid Token.");
		}
	}

	private void lbrace() throws SyntaxException {
		Token t = stream.getToken(index);
		if (isKind(t, TokenStream.Kind.LBRACE)) {
			consume();
		} else {
			errorList.add(new SyntaxException(stream.getToken(index),
					"Invalid token."));
			return;
		}
	}

	private void rbrace() throws SyntaxException {
		Token t = stream.getToken(index);
		if (isKind(t, TokenStream.Kind.RBRACE)) {
			consume();
		} else {
			errorList.add(new SyntaxException(stream.getToken(index),
					"Invalid token."));
			return;
		}
	}

	private void lsquare() throws SyntaxException {
		Token t = stream.getToken(index);
		if (isKind(t, TokenStream.Kind.LSQUARE)) {
			consume();
		} else {
			throw new SyntaxException(t, "Invalid Token.");
		}
	}

	private void rsquare() throws SyntaxException {
		Token t = stream.getToken(index);
		if (isKind(t, TokenStream.Kind.RSQUARE)) {
			consume();
		} else {
			throw new SyntaxException(t, "Invalid Token.");
		}
	}

	private Token parseEqual() throws SyntaxException {
		Token t = stream.getToken(index);
		if (isKind(t, TokenStream.Kind.EQ)) {
			consume();
		} else {
			throw new SyntaxException(t, "Invalid Token.");
		}
		return t;
	}

	private Token parseNEqual() throws SyntaxException {
		Token t = stream.getToken(index);
		if (isKind(t, TokenStream.Kind.NEQ)) {
			consume();
		} else {
			throw new SyntaxException(t, "Invalid Token.");
		}
		return t;
	}

	private Token assign() throws SyntaxException {
		Token t = stream.getToken(index);
		if (isKind(t, TokenStream.Kind.ASSIGN)) {
			consume();
		} else {
			throw new SyntaxException(t, "Invalid Token.");
		}
		return t;
	}

	private void dot() throws SyntaxException {
		Token t = stream.getToken(index);
		if (isKind(t, TokenStream.Kind.DOT)) {
			consume();
		} else {
			throw new SyntaxException(t, "Invalid Token");
		}
	}

	private void comma() throws SyntaxException {
		Token t = stream.getToken(index);
		if (isKind(t, TokenStream.Kind.COMMA)) {
			consume();
		} else {
			throw new SyntaxException(t, "Invalid Token");
		}
	}

	private void question() throws SyntaxException {
		Token t = stream.getToken(index);
		if (isKind(t, TokenStream.Kind.QUESTION)) {
			consume();
		} else {
			throw new SyntaxException(t, "Invalid Token");
		}
	}

	private void colon() throws SyntaxException {
		Token t = stream.getToken(index);
		if (isKind(t, TokenStream.Kind.COLON)) {
			consume();
		} else {
			throw new SyntaxException(t, "Invalid Token");
		}
	}

	private Token parseSignOR() throws SyntaxException {
		Token t = stream.getToken(index);
		if (isKind(t, TokenStream.Kind.OR)) {
			consume();
		} else {
			throw new SyntaxException(t, "Invalid Token");
		}
		return t;
	}

	private Token parseSignAND() throws SyntaxException {
		Token t = stream.getToken(index);
		if (isKind(t, TokenStream.Kind.AND)) {
			consume();
		} else {
			throw new SyntaxException(t, "Invalid Token");
		}
		return t;
	}

	private Token lthan() throws SyntaxException {
		Token t = stream.getToken(index);
		if (isKind(t, TokenStream.Kind.LT)) {
			consume();
		} else {
			throw new SyntaxException(t, "Invalid Token");
		}
		return t;
	}

	private Token gthan() throws SyntaxException {
		Token t = stream.getToken(index);
		if (isKind(t, TokenStream.Kind.GT)) {
			consume();
		} else {
			throw new SyntaxException(t, "Invalid Token");
		}
		return t;
	}

	private Token leq() throws SyntaxException {
		Token t = stream.getToken(index);
		if (isKind(t, TokenStream.Kind.LEQ)) {
			consume();
		} else {
			throw new SyntaxException(t, "Invalid Token");
		}
		return t;
	}

	private Token geq() throws SyntaxException {
		Token t = stream.getToken(index);
		if (isKind(t, TokenStream.Kind.GEQ)) {
			consume();
		} else {
			throw new SyntaxException(t, "Invalid Token");
		}
		return t;
	}

	private Token lshift() throws SyntaxException {
		Token t = stream.getToken(index);
		if (isKind(t, TokenStream.Kind.LSHIFT)) {
			consume();
		} else {
			throw new SyntaxException(t, "Invalid Token");
		}
		return t;
	}

	private Token rshift() throws SyntaxException {
		Token t = stream.getToken(index);
		if (isKind(t, TokenStream.Kind.RSHIFT)) {
			consume();
		} else {
			throw new SyntaxException(t, "Invalid Token");
		}
		return t;
	}

	private Token plus() throws SyntaxException {
		Token t = stream.getToken(index);
		if (isKind(t, TokenStream.Kind.PLUS)) {
			consume();
		} else {
			throw new SyntaxException(t, "Invalid Token");
		}
		return t;
	}

	private Token minus() throws SyntaxException {
		Token t = stream.getToken(index);
		if (isKind(t, TokenStream.Kind.MINUS)) {
			consume();
		} else {
			throw new SyntaxException(t, "Invalid Token");
		}
		return t;
	}

	private Token times() throws SyntaxException {
		Token t = stream.getToken(index);
		if (isKind(t, TokenStream.Kind.TIMES)) {
			consume();
		} else {
			throw new SyntaxException(t, "Invalid Token");
		}
		return t;
	}

	private Token div() throws SyntaxException {
		Token t = stream.getToken(index);
		if (isKind(t, TokenStream.Kind.DIV)) {
			consume();
		} else {
			throw new SyntaxException(t, "Invalid Token");
		}
		return t;
	}

	private Token mod() throws SyntaxException {
		Token t = stream.getToken(index);
		if (isKind(t, TokenStream.Kind.MOD)) {
			consume();
		} else {
			throw new SyntaxException(t, "Invalid Token");
		}
		return t;
	}

	private Token intLit() throws SyntaxException {
		Token t = stream.getToken(index);
		if (isKind(t, TokenStream.Kind.INT_LIT)) {
			consume();
		} else {
			throw new SyntaxException(t, "Invalid Token");
		}
		return t;
	}

	private Token stringLit() throws SyntaxException {
		Token t = stream.getToken(index);
		if (isKind(t, TokenStream.Kind.STRING_LIT)) {
			consume();
		} else {
			throw new SyntaxException(t, "Invalid Token");
		}
		return t;
	}

	private Token boolLit() throws SyntaxException {
		Token t = stream.getToken(index);
		if (isKind(t, TokenStream.Kind.BOOLEAN_LIT)) {
			consume();
		} else {
			throw new SyntaxException(t, "Invalid Token");
		}
		return t;
	}

	private Token not() throws SyntaxException {
		Token t = stream.getToken(index);
		if (isKind(t, TokenStream.Kind.NOT)) {
			consume();
		} else {
			throw new SyntaxException(t, "Invalid Token");
		}
		return t;
	}

	// ////////////////////// Consume //////////////////////////////////////////
	private void consume() {
		index++;
	}
}
// ////////////////////////////////////// End /////////////////////////////